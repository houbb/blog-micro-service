import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as e,o as n}from"./app-DAaD84tA.js";const t={};function r(h,a){return n(),i("div",null,[...a[0]||(a[0]=[e(`<p>在复杂的分布式系统中，故障的传播往往比故障本身更具破坏性。一个组件的故障可能通过服务调用链迅速传播到整个系统，导致级联故障和系统雪崩。熔断器模式和隔板模式是两种重要的容错设计模式，它们能够有效防止故障的传播，提高系统的稳定性和可靠性。本章将深入探讨这两种模式的原理、实现和应用。</p><h2 id="熔断器模式-circuit-breaker-pattern" tabindex="-1"><a class="header-anchor" href="#熔断器模式-circuit-breaker-pattern"><span>熔断器模式（Circuit Breaker Pattern）</span></a></h2><p>熔断器模式的灵感来源于电力系统中的保险丝，当电流超过安全阈值时自动断开电路，保护整个电力系统。在软件系统中，熔断器模式通过监控服务调用的健康状况，在故障率达到一定阈值时暂时切断对该服务的调用，防止故障进一步传播。</p><h3 id="熔断器的工作原理" tabindex="-1"><a class="header-anchor" href="#熔断器的工作原理"><span>熔断器的工作原理</span></a></h3><p>熔断器有三种状态：</p><h4 id="_1-关闭状态-closed-state" tabindex="-1"><a class="header-anchor" href="#_1-关闭状态-closed-state"><span>1. 关闭状态（Closed State）</span></a></h4><p>正常状态下，熔断器处于关闭状态，所有请求都会转发到目标服务：</p><ul><li>监控每次请求的成功和失败情况</li><li>统计失败率和响应时间</li><li>当失败率超过阈值时切换到打开状态</li></ul><h4 id="_2-打开状态-open-state" tabindex="-1"><a class="header-anchor" href="#_2-打开状态-open-state"><span>2. 打开状态（Open State）</span></a></h4><p>当故障率达到阈值时，熔断器切换到打开状态：</p><ul><li>所有请求立即失败，不转发到目标服务</li><li>启动计时器，等待超时时间结束后进入半开状态</li><li>防止故障服务拖垮整个系统</li></ul><h4 id="_3-半开状态-half-open-state" tabindex="-1"><a class="header-anchor" href="#_3-半开状态-half-open-state"><span>3. 半开状态（Half-Open State）</span></a></h4><p>超时时间结束后，熔断器进入半开状态进行试探：</p><ul><li>允许有限数量的请求通过</li><li>如果请求成功，则认为服务已恢复，切换到关闭状态</li><li>如果请求失败，则重新进入打开状态</li></ul><h3 id="熔断器的关键参数" tabindex="-1"><a class="header-anchor" href="#熔断器的关键参数"><span>熔断器的关键参数</span></a></h3><h4 id="失败阈值-failure-threshold" tabindex="-1"><a class="header-anchor" href="#失败阈值-failure-threshold"><span>失败阈值（Failure Threshold）</span></a></h4><p>触发熔断的失败率阈值，通常设置为50%或更高。当连续请求的失败率超过此阈值时，熔断器切换到打开状态。</p><h4 id="超时时间-timeout-duration" tabindex="-1"><a class="header-anchor" href="#超时时间-timeout-duration"><span>超时时间（Timeout Duration）</span></a></h4><p>熔断器在打开状态下保持的时间，通常设置为几秒到几分钟。超时时间结束后，熔断器进入半开状态。</p><h4 id="请求量阈值-request-volume-threshold" tabindex="-1"><a class="header-anchor" href="#请求量阈值-request-volume-threshold"><span>请求量阈值（Request Volume Threshold）</span></a></h4><p>触发熔断所需的最小请求数量。在请求数量较少时，即使失败率较高也不会触发熔断，避免因偶然失败导致误判。</p><h4 id="慢调用阈值-slow-call-threshold" tabindex="-1"><a class="header-anchor" href="#慢调用阈值-slow-call-threshold"><span>慢调用阈值（Slow Call Threshold）</span></a></h4><p>将响应时间超过指定阈值的调用视为失败，防止慢服务拖慢整个系统。</p><h3 id="熔断器的实现机制" tabindex="-1"><a class="header-anchor" href="#熔断器的实现机制"><span>熔断器的实现机制</span></a></h3><h4 id="滑动窗口算法" tabindex="-1"><a class="header-anchor" href="#滑动窗口算法"><span>滑动窗口算法</span></a></h4><p>使用滑动窗口统计最近一段时间内的请求情况：</p><ul><li><strong>时间窗口</strong>：统计最近N秒内的请求数据</li><li><strong>桶计数</strong>：将时间窗口划分为多个桶，每个桶记录一段时间内的请求统计</li><li><strong>动态更新</strong>：随着时间推移，窗口不断滑动，旧数据被移除，新数据被加入</li></ul><h4 id="环形缓冲区" tabindex="-1"><a class="header-anchor" href="#环形缓冲区"><span>环形缓冲区</span></a></h4><p>使用固定大小的环形缓冲区存储请求结果：</p><ul><li><strong>高效存储</strong>：固定内存占用，避免内存泄漏</li><li><strong>快速统计</strong>：通过简单的计数操作即可获得统计结果</li><li><strong>时间衰减</strong>：旧的请求结果会自动被新结果覆盖</li></ul><h3 id="熔断器的高级特性" tabindex="-1"><a class="header-anchor" href="#熔断器的高级特性"><span>熔断器的高级特性</span></a></h3><h4 id="失败率计算策略" tabindex="-1"><a class="header-anchor" href="#失败率计算策略"><span>失败率计算策略</span></a></h4><p>不同的失败率计算策略适用于不同的场景：</p><ul><li><strong>基于请求数量</strong>：统计失败请求数占总请求数的比例</li><li><strong>基于时间窗口</strong>：统计最近一段时间内的失败率</li><li><strong>加权计算</strong>：为不同类型的失败分配不同的权重</li></ul><h4 id="自定义失败判断" tabindex="-1"><a class="header-anchor" href="#自定义失败判断"><span>自定义失败判断</span></a></h4><p>允许开发者自定义什么情况下算作失败：</p><ul><li><strong>HTTP状态码</strong>：将特定的HTTP状态码视为失败</li><li><strong>异常类型</strong>：根据抛出的异常类型判断是否失败</li><li><strong>响应时间</strong>：将超过阈值的响应时间视为失败</li></ul><h4 id="事件监听机制" tabindex="-1"><a class="header-anchor" href="#事件监听机制"><span>事件监听机制</span></a></h4><p>提供事件监听接口，允许外部系统监控熔断器状态变化：</p><ul><li><strong>状态变更事件</strong>：当熔断器状态发生变化时触发</li><li><strong>请求失败事件</strong>：当请求失败时触发</li><li><strong>熔断触发事件</strong>：当熔断器被触发时触发</li></ul><h2 id="隔板模式-bulkhead-pattern" tabindex="-1"><a class="header-anchor" href="#隔板模式-bulkhead-pattern"><span>隔板模式（Bulkhead Pattern）</span></a></h2><p>隔板模式的灵感来源于船舶设计中的水密隔舱，通过将船体分割成多个独立的舱室，即使部分舱室进水也不会影响整个船只的安全。在软件系统中，隔板模式通过资源隔离防止一个服务的故障影响到其他服务。</p><h3 id="隔板模式的核心思想" tabindex="-1"><a class="header-anchor" href="#隔板模式的核心思想"><span>隔板模式的核心思想</span></a></h3><p>隔板模式通过以下方式实现资源隔离：</p><h4 id="_1-线程池隔离" tabindex="-1"><a class="header-anchor" href="#_1-线程池隔离"><span>1. 线程池隔离</span></a></h4><p>为不同的服务或操作分配独立的线程池：</p><ul><li><strong>资源独立</strong>：每个服务使用独立的计算资源</li><li><strong>故障隔离</strong>：一个服务的线程耗尽可能不会影响其他服务</li><li><strong>性能监控</strong>：可以独立监控每个服务的资源使用情况</li></ul><h4 id="_2-连接池隔离" tabindex="-1"><a class="header-anchor" href="#_2-连接池隔离"><span>2. 连接池隔离</span></a></h4><p>为不同的外部服务分配独立的连接池：</p><ul><li><strong>数据库连接</strong>：为不同的数据库分配独立的连接池</li><li><strong>HTTP连接</strong>：为不同的外部API分配独立的HTTP连接池</li><li><strong>消息队列</strong>：为不同的消息队列分配独立的连接资源</li></ul><h4 id="_3-内存隔离" tabindex="-1"><a class="header-anchor" href="#_3-内存隔离"><span>3. 内存隔离</span></a></h4><p>通过JVM或操作系统的内存管理机制实现内存隔离：</p><ul><li><strong>堆内存分区</strong>：为不同的服务分配独立的堆内存区域</li><li><strong>直接内存限制</strong>：限制每个服务使用的直接内存大小</li><li><strong>垃圾回收隔离</strong>：减少GC对其他服务的影响</li></ul><h3 id="隔板模式的实现方式" tabindex="-1"><a class="header-anchor" href="#隔板模式的实现方式"><span>隔板模式的实现方式</span></a></h3><h4 id="基于线程池的实现" tabindex="-1"><a class="header-anchor" href="#基于线程池的实现"><span>基于线程池的实现</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 为不同服务创建独立的线程池</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ExecutorService</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> userServiceExecutor </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Executors</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">newFixedThreadPool</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ExecutorService</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> orderServiceExecutor </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Executors</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">newFixedThreadPool</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">20</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ExecutorService</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> paymentServiceExecutor </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Executors</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">newFixedThreadPool</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">15</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="基于信号量的实现" tabindex="-1"><a class="header-anchor" href="#基于信号量的实现"><span>基于信号量的实现</span></a></h4><p>使用信号量限制并发请求数量：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 限制订单服务的并发请求数</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Semaphore</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> orderServiceSemaphore </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Semaphore</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">50</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 限制支付服务的并发请求数</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Semaphore</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> paymentServiceSemaphore </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Semaphore</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">30</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="基于容器的实现" tabindex="-1"><a class="header-anchor" href="#基于容器的实现"><span>基于容器的实现</span></a></h4><p>使用Docker容器或Kubernetes Pod实现进程级别的隔离：</p><ul><li><strong>资源限制</strong>：为每个容器设置CPU和内存限制</li><li><strong>网络隔离</strong>：通过网络策略隔离不同服务的网络访问</li><li><strong>存储隔离</strong>：为不同服务分配独立的存储卷</li></ul><h3 id="隔板模式的优势" tabindex="-1"><a class="header-anchor" href="#隔板模式的优势"><span>隔板模式的优势</span></a></h3><h4 id="_1-提高系统稳定性" tabindex="-1"><a class="header-anchor" href="#_1-提高系统稳定性"><span>1. 提高系统稳定性</span></a></h4><p>通过资源隔离，防止一个服务的故障影响到其他服务，提高整个系统的稳定性。</p><h4 id="_2-优化资源利用" tabindex="-1"><a class="header-anchor" href="#_2-优化资源利用"><span>2. 优化资源利用</span></a></h4><p>可以根据不同服务的特点分配合适的资源，避免资源浪费。</p><h4 id="_3-简化故障诊断" tabindex="-1"><a class="header-anchor" href="#_3-简化故障诊断"><span>3. 简化故障诊断</span></a></h4><p>当某个服务出现问题时，可以快速定位到具体的隔离区域，简化故障诊断过程。</p><h4 id="_4-支持独立扩展" tabindex="-1"><a class="header-anchor" href="#_4-支持独立扩展"><span>4. 支持独立扩展</span></a></h4><p>可以根据不同服务的负载情况独立扩展资源，提高系统的灵活性。</p><h2 id="熔断器与隔板模式的结合应用" tabindex="-1"><a class="header-anchor" href="#熔断器与隔板模式的结合应用"><span>熔断器与隔板模式的结合应用</span></a></h2><p>在实际应用中，熔断器模式和隔板模式往往需要结合使用，形成更强大的容错能力：</p><h3 id="微服务架构中的应用" tabindex="-1"><a class="header-anchor" href="#微服务架构中的应用"><span>微服务架构中的应用</span></a></h3><p>在微服务架构中，每个服务都可能调用多个其他服务：</p><ul><li><strong>熔断器</strong>：为每个外部服务调用配置熔断器，防止故障传播</li><li><strong>隔板模式</strong>：为不同的服务调用分配独立的线程池和连接池</li></ul><h3 id="api网关中的应用" tabindex="-1"><a class="header-anchor" href="#api网关中的应用"><span>API网关中的应用</span></a></h3><p>API网关作为系统的入口，需要处理大量的并发请求：</p><ul><li><strong>熔断器</strong>：为后端服务配置熔断器，防止后端故障影响网关</li><li><strong>隔板模式</strong>：为不同的API路径分配独立的资源</li></ul><h3 id="数据库访问中的应用" tabindex="-1"><a class="header-anchor" href="#数据库访问中的应用"><span>数据库访问中的应用</span></a></h3><p>数据库访问是系统中的关键环节：</p><ul><li><strong>熔断器</strong>：监控数据库连接和查询的健康状况</li><li><strong>隔板模式</strong>：为不同的数据库操作分配独立的连接池</li></ul><h2 id="实际案例分析" tabindex="-1"><a class="header-anchor" href="#实际案例分析"><span>实际案例分析</span></a></h2><h3 id="netflix-hystrix的实现" tabindex="-1"><a class="header-anchor" href="#netflix-hystrix的实现"><span>Netflix Hystrix的实现</span></a></h3><p>Netflix Hystrix是熔断器模式的经典实现：</p><ul><li><strong>命令模式</strong>：将每个服务调用封装为独立的命令</li><li><strong>线程池隔离</strong>：为不同的服务调用分配独立的线程池</li><li><strong>实时监控</strong>：提供实时的监控和告警功能</li><li><strong>降级机制</strong>：在服务不可用时提供降级处理</li></ul><h3 id="resilience4j的应用" tabindex="-1"><a class="header-anchor" href="#resilience4j的应用"><span>Resilience4j的应用</span></a></h3><p>Resilience4j是新一代的容错库，提供了更轻量级的实现：</p><ul><li><strong>函数式编程</strong>：基于函数式编程思想设计API</li><li><strong>模块化设计</strong>：将不同的容错模式设计为独立的模块</li><li><strong>Spring Boot集成</strong>：与Spring Boot框架深度集成</li></ul><h3 id="kubernetes中的资源限制" tabindex="-1"><a class="header-anchor" href="#kubernetes中的资源限制"><span>Kubernetes中的资源限制</span></a></h3><p>Kubernetes通过资源配额和限制范围实现隔板模式：</p><ul><li><strong>资源请求和限制</strong>：为Pod设置CPU和内存的请求和限制</li><li><strong>命名空间隔离</strong>：通过命名空间实现资源的逻辑隔离</li><li><strong>服务质量等级</strong>：根据资源保障程度将Pod分为不同的QoS等级</li></ul><h2 id="最佳实践" tabindex="-1"><a class="header-anchor" href="#最佳实践"><span>最佳实践</span></a></h2><h3 id="_1-合理配置参数" tabindex="-1"><a class="header-anchor" href="#_1-合理配置参数"><span>1. 合理配置参数</span></a></h3><ul><li>根据服务特点和业务需求合理设置熔断器参数</li><li>定期调优参数，适应业务变化</li></ul><h3 id="_2-建立监控体系" tabindex="-1"><a class="header-anchor" href="#_2-建立监控体系"><span>2. 建立监控体系</span></a></h3><ul><li>实时监控熔断器和隔板模式的运行状态</li><li>设置合理的告警阈值，及时发现异常</li></ul><h3 id="_3-设计降级策略" tabindex="-1"><a class="header-anchor" href="#_3-设计降级策略"><span>3. 设计降级策略</span></a></h3><ul><li>为被熔断的服务设计合理的降级处理逻辑</li><li>提供友好的用户体验，避免服务中断</li></ul><h3 id="_4-定期演练测试" tabindex="-1"><a class="header-anchor" href="#_4-定期演练测试"><span>4. 定期演练测试</span></a></h3><ul><li>定期进行故障演练，验证熔断器和隔板模式的有效性</li><li>根据演练结果优化配置和策略</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>熔断器模式和隔板模式是构建高可用分布式系统的重要设计模式。熔断器模式通过快速失败和故障隔离防止故障传播，而隔板模式通过资源隔离提高系统的稳定性和资源利用率。在实际应用中，这两种模式往往需要结合使用，形成完整的容错体系。</p><p>通过合理设计和实现这两种模式，我们可以显著提高系统的容错能力，确保在面对各种故障时系统仍能稳定运行。下一章我们将探讨幂等性与补偿事务，了解如何保证分布式系统中的操作一致性。</p>`,104)])])}const o=s(t,[["render",r]]),d=JSON.parse('{"path":"/posts/fault-recovery/008-2-4-Circuit-Breaker-Bulkhead-Patterns.html","title":"熔断器与隔板模式 (Circuit Breaker & Bulkhead Patterns)","lang":"zh-CN","frontmatter":{"title":"熔断器与隔板模式 (Circuit Breaker & Bulkhead Patterns)","date":"2025-08-31T00:00:00.000Z","categories":["容错与灾难恢复"],"tags":["fault-recovery"],"published":true,"description":"在复杂的分布式系统中，故障的传播往往比故障本身更具破坏性。一个组件的故障可能通过服务调用链迅速传播到整个系统，导致级联故障和系统雪崩。熔断器模式和隔板模式是两种重要的容错设计模式，它们能够有效防止故障的传播，提高系统的稳定性和可靠性。本章将深入探讨这两种模式的原理、实现和应用。 熔断器模式（Circuit Breaker Pattern） 熔断器模式的...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"熔断器与隔板模式 (Circuit Breaker & Bulkhead Patterns)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-08-31T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-07T09:05:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://houbb.github.io/blog-micro-service/posts/fault-recovery/008-2-4-Circuit-Breaker-Bulkhead-Patterns.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"熔断器与隔板模式 (Circuit Breaker & Bulkhead Patterns)"}],["meta",{"property":"og:description","content":"在复杂的分布式系统中，故障的传播往往比故障本身更具破坏性。一个组件的故障可能通过服务调用链迅速传播到整个系统，导致级联故障和系统雪崩。熔断器模式和隔板模式是两种重要的容错设计模式，它们能够有效防止故障的传播，提高系统的稳定性和可靠性。本章将深入探讨这两种模式的原理、实现和应用。 熔断器模式（Circuit Breaker Pattern） 熔断器模式的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-07T09:05:07.000Z"}],["meta",{"property":"article:tag","content":"fault-recovery"}],["meta",{"property":"article:published_time","content":"2025-08-31T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-07T09:05:07.000Z"}]]},"git":{"createdTime":1756698707000,"updatedTime":1757235907000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1},{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":2,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":9.01,"words":2704},"filePathRelative":"posts/fault-recovery/008-2-4-Circuit-Breaker-Bulkhead-Patterns.md","excerpt":"<p>在复杂的分布式系统中，故障的传播往往比故障本身更具破坏性。一个组件的故障可能通过服务调用链迅速传播到整个系统，导致级联故障和系统雪崩。熔断器模式和隔板模式是两种重要的容错设计模式，它们能够有效防止故障的传播，提高系统的稳定性和可靠性。本章将深入探讨这两种模式的原理、实现和应用。</p>\\n<h2>熔断器模式（Circuit Breaker Pattern）</h2>\\n<p>熔断器模式的灵感来源于电力系统中的保险丝，当电流超过安全阈值时自动断开电路，保护整个电力系统。在软件系统中，熔断器模式通过监控服务调用的健康状况，在故障率达到一定阈值时暂时切断对该服务的调用，防止故障进一步传播。</p>","autoDesc":true}');export{o as comp,d as data};
